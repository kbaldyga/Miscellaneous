<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
  <head>
    <title>Programowanie funkcyjne</title>
    <meta http-equiv="content-type" content="text/html; charset=ISO-8859-2">
    <style type="text/css">
      body { font-family: sans-serif }
    </style>
  </head>
  <body>
    <table>
      <tbody>
	<tr>
	  <td>
	    <table cellpadding="20">
	      <tbody>
		<tr>
		  <td>
		    <b>Programowanie funkcyjne, II UWr, 2008/09<br>
		      Lista zadañ nr 6 (na 13.11.2008)</b> 
		  </td>
		</tr> 
	    </tbody>
	    </table>
	  </td>
	</tr>
	<tr>
	  <td>
	    <table cellpadding="20" width="100%">
	      <tbody>
		<tr>
		  <th>
		    Czê¶æ I
		  </th>
		</tr>
<!--
		<tr>
		  <td>
		    <h4>Zadanie 1 (6p.)</h4>
		    Definiujemy typ danych do reprezentacji drzew binarnych przechowuj±cych
		    warto¶ci zarówno w wêz³ach jak i w li¶ciach:
		    <blockquote>
		      <tt>
		      type 'a btree = Leaf of 'a 
		                    | Node of 'a btree * 'a * 'a btree
		      </tt>
		    </blockquote>
		    <ol>
		      <li>(2p.)  Napisz funkcjê numeruj±c± wêz³y i
			li¶cie drzewa binarnego w kolejno¶ci
			przechodzenia go w g³±b (preorder). Na
			przyk³ad, tak ponumerowan± wersj± drzewa
			<blockquote>
			  <tt>Node (Node (Leaf 'a', 'b', Leaf 'c'), 'd', Leaf 'e')</tt>
			</blockquote>
			jest
			<blockquote>
			  <tt>Node (Node (Leaf 3, 2, Leaf 4), 1, Leaf 5)</tt>.
			</blockquote>
		      </li>		      
		      <li>(4p.)  Napisz funkcjê numeruj±c± wêz³y i
			liscie drzewa binarnego w kolejno¶ci
			przechodzenia go wszerz.  Na przyk³ad, tak
			ponumerowan± wersj± drzewa
			<blockquote>
			  <tt>Node (Node (Leaf 'a', 'b', Leaf 'c'), 'd', Leaf 'e')</tt>
			</blockquote>
			jest
			<blockquote>
			  <tt>Node (Node (Leaf 4, 2, Leaf 5), 1, Leaf 3)</tt>.
			</blockquote>
		      </li>
		    </ol>
		  </td>
		</tr>
-->
		<tr>
		  <td>
		    <h4>Zadanie 1 (6p.)</h4>
		    <I>Samefringe Problem.</I> Definiujemy typ danych
		    do reprezentacji drzew binarnych przechowuj±cych
		    warto¶ci w li¶ciach:
		    <blockquote>
		      <tt>
		      type 'a btree = Leaf of 'a 
		                    | Node of 'a btree * 'a btree
		      </tt>
		    </blockquote>
		    Dwa drzewa binarne typu <tt>t btree</tt> maj±
		    jednakowe korony (zak³adamy, ¿e obiekty
		    typu <tt>t</tt> s± porównywalne), je¶li listy
		    utworzone przez odczytanie warto¶ci w ich li¶ciach
		    od lewej do prawej s± równe. Na przyk³ad drzewa
		    <blockquote>
		      <tt>
		      Node (Node (Leaf 1, 
		                  Leaf 2),
		            Leaf 3)
		      </tt>
		    </blockquote>		      
		    i
		    <blockquote>
		      <tt>
		      Node (Leaf 1, 
		            Node (Leaf 2, 
		                  Leaf 3))
		      </tt>
		    </blockquote>
		    maj± jednakowe korony, równe <tt>[1; 2; 3]</tt>.
		    <ol>
		      <li>(2p.)
			Napisz funkcjê rozstrzygaj±c± czy dwa drzewa
			maj± jednakowe korony, bazuj±c bezpo¶rednio na
			definicji i nie dbaj±c o efektywno¶æ
			rozwi±zania.
		      </li>
		      <li>(4p.)
			Wykorzystuj±c pojêcie odroczonego obliczenia,
			napisz efektywn± i czysto funkcyjn± wersjê
			funkcji <tt>samefringe</tt>, tj. tak±, która
			przerywa obliczenia w momencie napotkania
			pierwszej ró¿nicy miêdzy koronami
			drzew. Podpowied¼: nale¿y odraczaæ
			trawersowanie prawego poddrzewa.
		      </li>
		    </ol>
		  </td>
		</tr>
	      </tbody>
	    </table>
	  </td>
	</tr>
	<tr>
	  <td>
	    <table cellpadding="20" width="100%">
	      <tbody>
		<tr>
		  <th>
		    Czê¶æ II
		  </th>
		</tr>
		<tr>
		  <td>
		    <h4>Zadanie 2 (4p.)</h4> Zdefiniuj nastêpuj±ce
		    operacje na listach leniwych typu <tt>'a
		    llist</tt>, przydatne w implementacji algorytmów z
		    nawrotami:
		    <ul>
		      <li>
			<tt>fail : 'a llist</tt>, reprezentuje pust± kolekcjê rozwi±zañ;
		      </li>
		      <li>
			<tt>succeed : 'a -> 'a llist</tt>, zwraca
			jednoelementow± kolekcjê zawieraj±c±
			znalezione rozwi±zanie;
		      </li>
		      <li>
			<tt>collect : 'a llist llist -> 'a llist</tt>,
			zwraca konkatenacjê podanych kolekcji rozwi±zañ.			
		      </li>
		    </ul>
		    Zaimplementuj powy¿sze operacje, a nastêpnie u¿yj
		    ich wraz z innymi standardowymi operacjami na
		    listach leniwych (<tt>lmap</tt>, <tt>lfilter</tt>, etc.) do jak
		    najzwiê¼lejszego rozwi±zania problemu n
		    hetmanów. Nie powiniene¶ sugerowaæ siê
		    rozwi±zaniem z wyk³adu, chocia¿ mo¿esz wykorzystaæ
		    niektóre z przedstawionych tam funkcji pomocniczych,
		    np. <tt>isQueenSafe</tt>.
<br><br>
<b>Przyk³adowe rozwi±zanie na listach leniwych: <a href="nqueens.ml">nqueens.ml</a>.</b>
		  </td>
		</tr>
		<tr>
		  <td>
		    <h4>Zadanie 3 (6p.)</h4> Tablica funkcyjna to
		    struktura danych, która podobnie jak tablica
		    imperatywna, pozwala na swobodny dostêp do swoich
		    sk³adowych (poprzez ich indeksy w
		    tablicy). Jednak¿e, w przeciwieñstwie do tablicy
		    imperatywnej, operacje modyfikuj±ce sk³adowe
		    tablicy funkcyjnej nie nadpisuj± istniej±cej
		    tablicy, a tworz± jej kopiê, przy czym oryginalna
		    kopia nadal istnieje i mo¿e byæ u¿ywana w dalszych
		    obliczeniach. Takie struktury sprawdzaj± siê
		    lepiej ni¿ tablice imperatywne np. w algorytmach
		    niedeterministycznych z nawrotami.
		    <br><br>
		    Rozwa¿my implementacjê tablic funkcyjnych za
		    pomoc± drzew binarnych postaci:
		    <blockquote>
		      <tt>
		      type 'a btree = Leaf | Node of 'a btree * 'a * 'a btree
		      </tt>
		    </blockquote>
		    Zak³adamy przy tym, ¿e drzewo reprezentuje tablicê
		    indeksowan± liczbami ca³kowitymi od 1 do n, a
		    ¶cie¿ka do sk³adowej o indeksie k, wyznaczona jest
		    przez seriê dzieleñ modulo 2, a¿ do osiagniêcia
		    warto¶ci 1, wg zasady: je¶li k mod 2 = 0, to
		    wybieramy lewego syna, a w przeciwnym razie -
		    prawego, a nastêpnie poszukujemy elementu o
		    indeksie k div 2. W przypadku drzew
		    zbalansowanych, a z takimi mamy tu do czynienia,
		    dostêp do k-tego elementu wymaga log k kroków.

		    <br><br> Zdefiniuj typ danych <tt>'a array</tt>
		    (wraz z drzewem warto przechowywaæ najwy¿szy
		    indeks w tablicy) oraz nastêpuj±ce operacje na
		    tablicach funkcyjnych:
		    <ul>
		      <li>
			<tt>aempty : 'a array</tt>, tablica pusta;
		      </li>
		      <li>
			<tt>asub : 'a array -> int -> 'a</tt>, pobranie sk³adowej o zadanym indeksie;
		      </li>
		      <li>
			<tt>aupdate : 'a array -> int -> 'a -> 'a array</tt>, modyfikacja sk³adowej o zadanym indeksie;
		      </li>
		      <li>
			<tt>ahiext : 'a array -> 'a -> 'a array</tt>, rozszerzenie tablicy o jedn± sk³adow±;
		      </li>
		      <li>
			<tt>ahirem : 'a array -> 'a array</tt>, usuniêcie sk³adowej o najwy¿szym indeksie.
		      </li>
		    </ul>
		  </td>
		</tr>
	      </tbody>
	    </table>
	  </td>
	</tr>
      </tbody>
    </table>
  </body>
</html>
