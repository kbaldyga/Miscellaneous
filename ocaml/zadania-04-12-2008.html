<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><title>Programowanie funkcyjne</title>

  
    
    <meta http-equiv="content-type" content="text/html; charset=ISO-8859-2">
    <style type="text/css">
      body { font-family: sans-serif }
    </style></head><body>
    <table>
      <tbody>
	<tr>
	  <td>
	    <table cellpadding="20">
	      <tbody>
		<tr>
		  <td>
		    <b>Programowanie funkcyjne, II UWr, 2008/09<br>
		      Lista zadañ nr 9 (na 04.12.2008)</b> 
		  </td>
		</tr> 
	    </tbody>
	    </table>
	  </td>
	</tr>
	<tr>
	  <td>
	    <table cellpadding="20" width="100%">
	      <tbody>
		<tr>
		  <th>
		    Czê¶æ I
		  </th>
		</tr>
		<tr>
		  <td>
		    <h4>Zadanie 1 (8p.)</h4>
		    Chcemy stworzyæ sygnaturê dla funkcyjnych reprezentacji grafów
		    skierowanych, sparametryzowanych przez abstrakcyjne typy wierzcho³ków
		    i krawêdzi.
		    
		    W tym celu tworzymy sygnaturê dla typu wierzcho³ków: 
<pre>module type VERTEX =
sig
  type t
  type label

  val equal : t -&gt; t -&gt; bool
  val create : label -&gt; t
  val label : t -&gt; label  
end
</pre>

gdzie typ <tt>t</tt> reprezentuje abstrakcyjny typ wierzcho³ków,
typ <tt>label</tt> reprezentuje abstrakcyjny typ etykiet wierzcho³ków,
a funkcja <tt>equal</tt> pozwala porównywaæ
wierzcho³ki. Funkcja <tt>create</tt> tworzy nowy wierzcho³ek na
podstawie etykiety, a funkcja <tt>label</tt> zwraca etykietê
wierzcho³ka.

<ol>
<li>Napisz analogiczn± sygnaturê dla typu krawêdzi przyjmuj±c, ¿e krawêdzie równie¿
mog± byæ etykietowane, porównywane, oraz dla ka¿dej krawêdzi powinna
istnieæ mo¿liwo¶æ wyznaczenia jej wierzcho³ka pocz±tkowego i
koñcowego.</li>
<li>Rozwa¿my nastêpnie sygnaturê dla grafów skierowanych:
<pre>module type GRAPH =
sig
  (* typ reprezentacji grafu *)
  type t

  module V : VERTEX
  type vertex = V.t

  module E : EDGE with type vertex = vertex

  type edge = E.t

  (* funkcje wyszukiwania *)
  val mem_v : t -&gt; vertex -&gt; bool
  val mem_e : t -&gt; edge -&gt; bool
  val mem_e_v : t -&gt; vertex -&gt; vertex -&gt; bool
  val find_e : t -&gt; vertex -&gt; vertex -&gt; edge
  val succ : t -&gt; vertex -&gt; vertex list
  val pred : t -&gt; vertex -&gt; vertex list
  val succ_e : t -&gt; vertex -&gt; edge list
  val pred_e : t -&gt; vertex -&gt; edge list

  (* funkcje modyfikacji *) 
  val empty : t
  val add_e : t -&gt; edge -&gt; t
  val add_v : t -&gt; vertex -&gt; t
  val rem_e : t -&gt; edge -&gt; t
  val rem_v : t -&gt; vertex -&gt; t

  (* iteratory *)
  val fold_v : (vertex -&gt; 'a -&gt; 'a) -&gt; t -&gt; 'a -&gt; 'a
  val fold_e : (edge -&gt; 'a -&gt; 'a) -&gt; t -&gt; 'a -&gt; 'a
end
</pre>
Zaimplementuj modu³ <tt>Graph</tt> zgodny 
z sygnatur± <tt>GRAPH</tt> dla dowolnie wybranej reprezentacji funkcyjnej
  grafu. (Funkcje <tt>succ</tt> i <tt>pred</tt> wyznaczaj±
odpowiednio listê nastêpników i poprzedników danego wierzcho³ka, a
funkcje <tt>succ_e</tt> i <tt>pred_e</tt> wyznaczaj± odpowiednio
listê krawêdzi wychodz±cych i wchodz±cych do danego wierzcho³ka.)
<b>Uwaga:</b> Mo¿esz zaimplementowaæ kilka wybranych funkcji (co
najmniej 4), a
resztê dokoñczyæ w domu.</li>
<li>Przetestuj dzia³anie swojej implementacji na przyk³adowych danych
  (w tym celu zaimplementuj równie¿ modu³y <tt>Vertex</tt>
  i <tt>Edge</tt> zgodne z odpowiednimi sygnaturami).</li>
<li>Napisz funktor, który przyjmuj±c jako argumenty
  modu³y <tt>V:VERTEX</tt> oraz <tt>E:EDGE</tt> zwraca modu³ zgodny z
  sygnatur± <tt>GRAPH</tt>.</li>
</ol>
<b>Uwaga!</b> Pamiêtaj o deklaracjach wspó³dzielenia typów.
		  </td>
		</tr>
	      </tbody>
	    </table>
	  </td>
	</tr>
	<tr>
	  <td>
	    <table cellpadding="20" width="100%">
	      <tbody>
		<tr>
		  <th>
		    Czê¶æ II
		  </th>
		</tr>
		<tr>
		  <td>
		    <h4>Zadanie 2 (4p.)</h4>  
		    Korzystaj±c z sygnatury <tt>GRAPH</tt> napisz funkcje przechodzenia
		    grafu w g³±b i wszerz. Przetestuj te funkcje na swojej implementacji.
		  </td>
		</tr>
	      </tbody>
	    </table>
	  </td>
	</tr>
</tbody>
</table>

</body></html>
